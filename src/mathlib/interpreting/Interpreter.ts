import { Argument } from "../Argument";
import { Expression } from "../expressions/Expression";
import { Graph } from "../Graph"
import { MathGraphNode } from "../MathGraphNode"


/**
 * Takes a graph and collapses any arguments that are obvious.
 */
export class Interpreter {
    public constructor (config: InterpreterSettings) {
        this.config = config
    }

    /**
     * Creates a SkipSet for the given graph following
     * the rules assigned to the Interpreter.
     * @effects nothing
     */
    public process(graph: Graph): SkipSet {
        this.graph = graph
        const result = new SkipSet();

        for (const n of graph.getNodes()) {
            if (n !instanceof Expression) continue
            const node = n as Expression

            let next: Expression = node
            // Get the longest path we can
            while (this.hasOneOutEdge(next)) {
                const old = next
                const neighbor = this.graph.getNeighbors(next, "out")![0]
                if (neighbor !instanceof Expression) break
                const edge = this.graph.getEdge(old, next)!

                if (edge instanceof Argument 
                    && this.config.skips.has(edge.ruleId)
                    && next instanceof Expression) {
                    next = neighbor as Expression
                } else {
                    break
                } 
            }

            result.addSkip(node, next)
        }

        this.graph = null
        return result
    }

    //public process(path: MathGraphNode[])

    private hasOneOutEdge(node: MathGraphNode): boolean {
        return this.graph?.getDegree(node, "out") == 1
    }


    // Null after every process call.
    private graph: Graph | null = null;
    private readonly config: InterpreterSettings
}

export interface InterpreterSettings {
    /**
     * Set of rule ids. Arguments generated by these rules
     * will be bridged over in the graph.
     */
    skips: Set<string>
}

/**
 * Currently only supports expressions.
 * TODO: Figure out arguments.
 */
export class SkipSet {

    /**
     * Finds the next expression that should be displayed.
     * The input and result expression should be displayed as
     * connected by the input's out argument. 
     * 
     * There will be
     * exactly one simple path connecting the output and
     * result.
     * @param input 
     * @return Null if the input has no skip mapped to it.
     */
    public next(input: Expression): Expression | null {
        if (this.skips.has(input)) return this.skips.get(input)!
        return null
    }

    /**
     * Adds the start end pair to the skip set. If already included,
     * does nothing. If the given start already has an end assigned
     * and the assigned /= the given end, throws. If start == end,
     * does nothing.
     * @param start 
     * @param end 
     */
    public addSkip(start: Expression, end: Expression): void {
        if (start == end) return
        if (this.skips.has(start) && this.skips.get(start)! != end) throw new Error("Adding another end to SkipSet")
        this.skips.set(start, end)
    }

    private skips = new Map<Expression, Expression>()
}